
<!-- saved from url=(0055)https://minho-kim-uos.github.io/webgpu/src/examine.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Control the Tank</title>
    </head>
    <body>
        <h1 align="center">Control the Tank</h1>
        <script type="importmap">
        {
            "imports": {
                "three": "https://threejs.org/build/three.module.min.js",
                "three/addons/": "https://threejs.org/examples/jsm/",
                "wgpu-matrix": "https://wgpu-matrix.org/dist/2.x/wgpu-matrix.module.min.js"
            }


        }</script>
        <script type="module">
            import*as THREE from 'three'
            import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
            import {OBJLoader} from "three/addons/loaders/OBJLoader.js";
            import {vec2, vec3, vec4, mat4, utils} from 'wgpu-matrix';

            const loc_position = 3;
            const loc_normal = 2;
            const loc_uv = 1;

            const loc_inter_stage_normal = 1;
            const loc_inter_stage_uv = 2;
            const loc_inter_stage_position = 3;
            const loc_inter_stage_surfaceToView = 4;

            const id_group = 0;
            const binding_uniforms = 0;
            const binding_sampler = 1;
            const binding_color_texture = 2;
            const binding_etc_texture = 3;
            const binding_normal_texture = 4;

            const format_depth_texture = 'depth24plus';

            const light_direction = [-0.5, -0.5, -0.5];



            async function main() {
                const adapter = await navigator.gpu?.requestAdapter();
                const device = await adapter?.requestDevice();
                if(!device) {
                    throw Error("WebGPU not supported.");
                }
                const canvas = document.querySelector("#webgpu");
                const context = canvas.getContext("webgpu");
                const preferredFormat = navigator.gpu.getPreferredCanvasFormat();
                context.configure({
                    device,
                    format: preferredFormat,
                });
                let canvasTexture = context.getCurrentTexture();

                class UI {
                    static NONE = 0;
                    static ROTATING = 1;
                    static TRANSLATING = 2;
                    static mouseMove = UI.NONE;
                    static camera = {fovy:60, position:vec3.create(0,0,-3), near:0.1, far:100};
                    static matrices = {
                        P: mat4.perspective(utils.degToRad(UI.camera.fovy), canvasTexture.width/canvasTexture.height, UI.camera.near, UI.camera.far),
                        R: mat4.identity(),
                    };
                    static onmousedown(ev) {
                        if(ev.buttons & 1)  { UI.mouseMove = UI.ROTATING; }
                        else if(ev.buttons & 4) { UI.mouseMove = UI.TRANSLATING ; }
                    };
                    static onmouseup(ev) {
                        UI.mouseMove = UI.NONE;
                    };
                    static onmousemove(ev) {
                        let offset = [ev.movementX, ev.movementY];
                        if (UI.mouseMove == UI.ROTATING) {
                            UI.update_VP();
                            let axis = unproject_vector([offset[1], offset[0], 0], UI.matrices.VP,
                                [0, 0, canvas.clientWidth, canvas.clientHeight]);
                            UI.matrices.R = mat4.rotate(UI.matrices.R, [axis[0], axis[1], axis[2]], utils.degToRad(vec2.lenSq(offset)*0.1)); 
                        }
                        else if(UI.mouseMove == UI.TRANSLATING) {
                            UI.update_VP();
                            let by = unproject_vector([offset[0], -offset[1], 0], UI.matrices.VP,
                                [0, 0, canvas.clientWidth, canvas.clientHeight]);
                            UI.camera.position = vec3.add(UI.camera.position, vec3.transformMat4(vec3.create(by[0], by[1], by[2]), UI.matrices.R));
                        }
                    };
                    static onwheel(ev) {
                        ev.preventDefault();
                        UI.camera.position[2] = -Math.max(1, Math.min(-UI.camera.position[2] + ev.deltaY*0.01, 50));
                        UI.update_VP();
                    };
                    static update_VP() {
                        UI.matrices.VP = mat4.multiply(mat4.translate(UI.matrices.P, UI.camera.position),UI.matrices.R);
                    }
                };

                UI.update_VP();


                canvas.onmousedown = UI.onmousedown;
                canvas.onmouseup = UI.onmouseup;
                canvas.onmousemove = UI.onmousemove;
                window.addEventListener("wheel", UI.onwheel, {passive:false});
            

                const grid = createGridAndAxes(device, preferredFormat);
                const tank = await loadTankGLTF(device, preferredFormat);

                const depthTexture = device.createTexture({
                    size: [canvasTexture.width, canvasTexture.height],
                    format: format_depth_texture,
                    usage: GPUTextureUsage.RENDER_ATTACHMENT,
                });
 

                let M = mat4.identity();

                let MVP;

                function render(time) {
                    
                    canvasTexture = context.getCurrentTexture();
                        
                    const encoder = device.createCommandEncoder();
                    const renderPass = encoder.beginRenderPass({
                        colorAttachments: [{
                            view: canvasTexture.createView(),
                            loadOp: "clear",
                            clearValue: {r:.3, g:.3, b:.3, a:1},
                            storeOp: "store",
                        }],
                        depthStencilAttachment: {
                            view: depthTexture.createView(),
                            depthClearValue: 1.0,
                            depthLoadOp: 'clear',
                            depthStoreOp: 'store',
                        },
                    });

                    // Render grid and model
                    MVP = mat4.multiply(UI.matrices.VP, M);
                    grid.render(renderPass, MVP);
                    tank.render(renderPass, MVP, UI);

                    renderPass.end();
                    const commandBuffer = encoder.finish();
                    device.queue.submit([commandBuffer]);

                    requestAnimationFrame(render);
                }

                requestAnimationFrame(render);

            }
            
            async function loadTankGLTF(device, preferredFormat) {
                const loader = new GLTFLoader();
            
                const root = await new Promise((resolve, reject) => {
                    loader.load(
                        "./tank.glb",
                        (model) => resolve(model),
                        null,
                        (error) => reject(error)
                    );
                });

                const tankAxes = createAxes(device, preferredFormat);

                // Parse GLTF hierarchy
                const bodyNode = root.scene.children[0].children.find(child => child.name === "nodebody");
                const turretNode = bodyNode.children.find(child => child.name === "nodeturret");
                const barrelNode = turretNode.children.find(child => child.name === "nodebarrel");

                let shells = []; // Array to store shell objects
                let isPaused = false; // Track whether shell movement is paused
                let barrelWorldMatrix;

                // Add this part to the script
                const currentKeyElement = document.querySelector("#current-key");

                document.addEventListener("keydown", (event) => {
                    const keyPressed = event.key;
                    const rotationYStep = utils.degToRad(10); // Rotation angle for Y-axis (10 degrees per step)
                    const rotationZStep = utils.degToRad(5); // Rotation angle for Z-axis (5 degrees per step)
                    const translationStep = 1; // Translation distance per step
                    const minBarrelAngle = 0; // Minimum barrel angle (0 degrees)
                    const maxBarrelAngle = utils.degToRad(50); // Maximum barrel angle (50 degrees)

                    if (event.key === "ArrowUp") {
                        // Calculate forward movement direction based on bodyNode's rotation
                        const forwardVector = vec3.create(
                            Math.cos(-bodyNode.rotation.y) * translationStep, // X-axis movement
                            0,                                              // Y-axis movement
                            Math.sin(-bodyNode.rotation.y) * translationStep // Z-axis movement
                        );
                        bodyNode.position.x += forwardVector[0];
                        bodyNode.position.z += forwardVector[2];
                    } else if (event.key === "ArrowDown") {
                        // Move backward (opposite direction of forwardVector)
                        const backwardVector = vec3.create(
                            -Math.cos(-bodyNode.rotation.y) * translationStep, // X-axis movement
                            0,                                                // Y-axis movement
                            -Math.sin(-bodyNode.rotation.y) * translationStep // Z-axis movement
                        );
                        bodyNode.position.x += backwardVector[0];
                        bodyNode.position.z += backwardVector[2];
                    } else if (event.key === "ArrowLeft") {
                        // Rotate bodyNode to the left
                        bodyNode.rotation.y += rotationYStep;
                    } else if (event.key === "ArrowRight") {
                        // Rotate bodyNode to the right
                        bodyNode.rotation.y -= rotationYStep;
                    } else if (event.key === "a" || event.key === "ㅁ") {
                        // Rotate turretNode to the left
                        turretNode.rotation.y += rotationYStep;
                    } else if (event.key === "d" || event.key === "ㅇ") {
                        // Rotate turretNode to the right
                        turretNode.rotation.y -= rotationYStep;
                    } else if (event.key === "w" || event.key === "ㅈ") {
                        // Rotate barrelNode upward (up to the maximum angle)
                        barrelNode.rotation.z = Math.min(barrelNode.rotation.z + rotationZStep, maxBarrelAngle);
                    } else if (event.key === "s" || event.key === "ㄴ") {
                        // Rotate barrelNode downward (down to the minimum angle)
                        barrelNode.rotation.z = Math.max(barrelNode.rotation.z - rotationZStep, minBarrelAngle);
                    } else if (event.key === " ") {
                        // Create a new shell
                        loadShellobj(device, preferredFormat).then((shell) => {    
                            
                            // Calculate direction vector based on barrel, turret, and body rotation
                            const barrelWorldRotationZ = barrelNode.rotation.z + utils.degToRad(10);
                            const turretWorldRotationY = turretNode.rotation.y;
                            const bodyWorldRotationY = bodyNode.rotation.y;
                        
                            // Create rotation matrices for Z and Y axes
                            const rotationZMatrix = mat4.rotateZ(mat4.identity(), barrelWorldRotationZ);
                            const turretRotationYMatrix = mat4.rotateY(mat4.identity(), turretWorldRotationY);
                            const bodyRotationYMatrix = mat4.rotateY(mat4.identity(), bodyWorldRotationY);
                        
                            // Combine body, turret, and barrel rotations into a single matrix
                            const combinedRotationMatrix = mat4.multiply(
                                mat4.multiply(bodyRotationYMatrix, turretRotationYMatrix),
                                rotationZMatrix
                            );
                        
                            // Transform default direction vector (along X-axis)
                            const barrelWorldDirection = vec3.transformMat4(vec3.create(1, 0, 0), combinedRotationMatrix);
                        
                            // Normalize direction vector
                            vec3.normalize(barrelWorldDirection, barrelWorldDirection);
                        
                            // Set initial position and rotation for the shell
                            const initialPosition = vec3.transformMat4(vec3.create(0.73, 0.14, 0), barrelWorldMatrix);
                        
                            shells.push({
                                render: shell.render,
                                position: initialPosition,
                                direction: barrelWorldDirection,
                                velocity: 0.5, // Initial speed
                                rotationMatrix: combinedRotationMatrix,
                            });
                        });
                    } else if (event.key === "p" || event.key === "ㅔ") {
                        // Toggle shell movement pause/resume
                        isPaused = !isPaused;
                    }

                    // Update the scene to reflect changes
                    root.scene.updateMatrixWorld();

                    // Update the current key text in the HTML
                    currentKeyElement.textContent = keyPressed;
                });

                const buffers = {};
            
                function processMesh(node, name) {
                    const meshNode = node.children.find(child => child.name === name);
                    const geometry = meshNode.geometry; // 이름 기반으로 메시 찾기
                    const positions = geometry.attributes.position.array;
                    const normals = geometry.attributes.normal.array;
                    const uvs = geometry.attributes.uv.array;
                    const indices = new Uint32Array(geometry.index.array);
                    const localPosition = meshNode.position;
            
                    buffers[name] = {
                        position: device.createBuffer({
                            size: positions.byteLength,
                            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                        }),
                        normal: device.createBuffer({
                            size: normals.byteLength,
                            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                        }),
                        uv: device.createBuffer({
                            size: uvs.byteLength,
                            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                        }),
                        index: device.createBuffer({
                            size: indices.byteLength,
                            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
                        }),
                        count: indices.length,
                        localPosition: localPosition
                    };
            
                    device.queue.writeBuffer(buffers[name].position, 0, positions);
                    device.queue.writeBuffer(buffers[name].normal, 0, normals);
                    device.queue.writeBuffer(buffers[name].uv, 0, uvs);
                    device.queue.writeBuffer(buffers[name].index, 0, indices);
                }
            
                // 각 계층의 메쉬를 처리
                processMesh(bodyNode, "body");
                processMesh(turretNode, "turret");
                processMesh(barrelNode, "barrel");

                // Create textures
                const colorTexture = await getTexture(device, "./textures/tank-color.jpg");
                const etcTexture = await getTexture(device, "./textures/tank-etc.png")
                const normalTexture = await getTexture(device, "./textures/tank-normal.png")

                const sampler = device.createSampler({magFilter:"linear", minFilter:"linear"});

                const bindGroupLayout = createBindGroupLayout(device);
            
                const uniformBufferSize = (16 + 16 + 4 + 4) * 4;
                const uniformBuffers = {
                    body: device.createBuffer({
                        size: uniformBufferSize,
                        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                    }),
                    turret: device.createBuffer({
                        size: uniformBufferSize,
                        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                    }),
                    barrel: device.createBuffer({
                        size: uniformBufferSize,
                        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                    }),
                };
                
                // offsets to the various uniform values in float32 indices
                const uniformValues = new Float32Array(uniformBufferSize / 4);
                const kWorldOffset = 0;
                const kWorldViewProjectionOffset = 16;
                const kLightDirectionOffset = 32;
                const kViewWorldPositionOffset = 36;

                
                const worldValue = uniformValues.subarray(kWorldOffset, kWorldOffset + 16);
                const worldViewProjectionValue = uniformValues.subarray(
                    kWorldViewProjectionOffset, kWorldViewProjectionOffset + 16);
                const lightDirectionValue =
                    uniformValues.subarray(kLightDirectionOffset, kLightDirectionOffset + 3);
                const viewWorldPositionValue = uniformValues.subarray(
                    kViewWorldPositionOffset, kViewWorldPositionOffset + 3);
            
                const src_shaders = `
                    struct VertexOut {
                        @builtin(position) position: vec4f,
                        @location(${loc_inter_stage_normal}) normal: vec3f,
                        @location(${loc_inter_stage_uv}) uv: vec2f,
                        @location(${loc_inter_stage_position}) pos: vec3f,
                        @location(${loc_inter_stage_surfaceToView}) surfaceToView: vec3f
                    };

                    struct Uniforms {
                        world: mat4x4f,
                        worldViewProjection: mat4x4f,
                        lightDirection: vec3f,
                        viewWorldPosition: vec3f,
                    };
            
                    @group(0) @binding(${binding_uniforms}) var<uniform> uni: Uniforms;
                    @group(0) @binding(${binding_sampler}) var my_sampler: sampler;
                    @group(0) @binding(${binding_color_texture}) var colorTexture: texture_2d<f32>;
                    @group(0) @binding(${binding_etc_texture}) var etcTexture: texture_2d<f32>;
                    @group(0) @binding(${binding_normal_texture}) var normalTexture: texture_2d<f32>;
            
                    @vertex
                    fn main_vert(
                        @location(${loc_position}) position: vec3f, 
                        @location(${loc_normal}) normal: vec3f,
                        @location(${loc_uv}) uv: vec2f
                    ) -> VertexOut {
                        var output: VertexOut;
                        output.position = uni.worldViewProjection * vec4f(position, 1.0);
                        output.normal = normalize((uni.world * vec4f(normal, 0)).xyz);
                        output.uv = uv;
                        output.pos = position;
                        let surfaceWorldPosition = (uni.world * vec4f(position, 1.0)).xyz;
                        output.surfaceToView = -uni.viewWorldPosition - surfaceWorldPosition;

                        return output;
                    }
            
                    @fragment
                    fn main_frag(
                        @location(${loc_inter_stage_normal}) normal: vec3f,
                        @location(${loc_inter_stage_uv}) uv: vec2f,
                        @location(${loc_inter_stage_position}) pos: vec3f,
                        @location(${loc_inter_stage_surfaceToView}) surfaceToView: vec3f
                    ) -> @location(0) vec4f {
                        // Calcualte perturbed normal
                        let norm = 2*(textureSample(normalTexture, my_sampler, uv).xyz - vec3f(.5));
                        let TBN = cotangent_frame(normal, -pos.xyz, uv);
                        let n = normalize(vec4(TBN*norm.xyz, 0)).xyz;
                        
                        // Calculate light
                        let texColor = textureSample(colorTexture, my_sampler, uv);
                        let etcColor = textureSample(etcTexture, my_sampler, uv);
                        let ao = etcColor.r;
                        let shininess = etcColor.g;
                        let metalness = etcColor.b;

                        let surfaceToLightDirection = normalize(-uni.lightDirection);
                        let surfaceToViewDirection = normalize(surfaceToView);
                        let halfVector = normalize(
                        surfaceToLightDirection + surfaceToViewDirection);

                        let light = dot(n, surfaceToLightDirection);
                        var specular = dot(n, halfVector);
                        specular = select(
                            0.0,                           // value if condition is false
                            pow(specular, shininess),  // value if condition is true
                            specular > 0.0);               // condition

                        // Ambient reflection
                        let ambientIntensity = 0.2; // Ambient light intensity (adjust as needed)
                        let ambientColor = vec3f(0.2, 0.2, 0.2); // Environment color (dark gray)
                        let ambient = ambientColor * ambientIntensity;

                        // Final color calculation
                        let diffuse = (texColor.rgb * light) * ao;
                        let finalColor = diffuse + specular * metalness + ambient;
                            
                        return vec4f(finalColor, texColor.a);
                    }

                    fn cotangent_frame(N: vec3f, p: vec3f, uv: vec2f) -> mat3x3f {
                        let dp1 = dpdx(p);
                        let dp2 = dpdy(p);
                        let duv1 = dpdx(uv);
                        let duv2 = dpdy(uv);

                        let dp2perp = cross(dp2, N);
                        let dp1perp = cross(N, dp1);
                        let T = dp2perp * duv1.x + dp1perp * duv2.x;
                        let B = dp2perp * duv1.y + dp1perp * duv2.y;

                        let invmax = inverseSqrt(max(dot(T,T), dot(B,B)));
                        return mat3x3f(T*invmax, B*invmax, N);
                    }

                `;
            
                const shaderModule = device.createShaderModule({
                    code: src_shaders,
                });
            
                const bindGroups = {
                    body: createBindGroup(device, bindGroupLayout, uniformBuffers.body, sampler, colorTexture, etcTexture, normalTexture),
                    turret: createBindGroup(device, bindGroupLayout, uniformBuffers.turret, sampler, colorTexture, etcTexture, normalTexture),
                    barrel: createBindGroup(device, bindGroupLayout, uniformBuffers.barrel, sampler, colorTexture, etcTexture, normalTexture),
                };

                const pipeline = device.createRenderPipeline({
                    layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                    vertex: {
                        module: shaderModule,
                        entryPoint: "main_vert",
                        buffers: [
                            {
                                arrayStride: 4 * 3,
                                attributes: [{ format: "float32x3", offset: 0, shaderLocation: loc_position }],
                            },
                            {
                                arrayStride: 4 * 3,
                                attributes: [{ format: "float32x3", offset: 0, shaderLocation: loc_normal }],
                            },
                            {
                                arrayStride: 4 * 2,
                                attributes: [{ format: "float32x2", offset: 0, shaderLocation: loc_uv }],
                            },
                        ],
                    },
                    fragment: {
                        module: shaderModule,
                        entryPoint: "main_frag",
                        targets: [{ format: preferredFormat }],
                    },
                    primitive: { topology: "triangle-list" },
                    depthStencil: {
                        depthWriteEnabled: true,
                        depthCompare: "less",
                        format: format_depth_texture,
                    },
                });
            
                function render(renderPass, baseMatrix, UI) {
                    const stack = [mat4.identity()]
                    let MVP = stack[stack.length - 1];
                    lightDirectionValue.set(vec3.normalize(light_direction));
                    viewWorldPositionValue.set(UI.camera.position);

                    /******** Body ********/
                    renderPass.setPipeline(pipeline);
                    renderPass.setVertexBuffer(0, buffers.body.position);
                    renderPass.setVertexBuffer(1, buffers.body.normal);
                    renderPass.setVertexBuffer(2, buffers.body.uv);
                    renderPass.setIndexBuffer(buffers.body.index, "uint32");

                    // Apply body position and rotation
                    stack.push(mat4.translate(mat4.clone(MVP), [...bodyNode.position]));
                    stack[stack.length - 1] = mat4.rotateY(stack[stack.length - 1], bodyNode.rotation.y);
                    MVP = stack[stack.length - 1];

                    worldValue.set(MVP);
                    worldViewProjectionValue.set(mat4.multiply(baseMatrix, MVP));
                    device.queue.writeBuffer(uniformBuffers.body, 0, uniformValues);
                    renderPass.setBindGroup(0, bindGroups.body);
                    renderPass.drawIndexed(buffers.body.count);

                    // Render tankAxes at body position
                    let axisMVP = mat4.translate(baseMatrix, [bodyNode.position.x, 0, bodyNode.position.z]);
                    axisMVP = mat4.rotateY(axisMVP, bodyNode.rotation.y);
                    tankAxes.render(renderPass, axisMVP);


                    /******** Turret ********/
                    renderPass.setPipeline(pipeline);
                    renderPass.setVertexBuffer(0, buffers.turret.position);
                    renderPass.setVertexBuffer(1, buffers.turret.normal);
                    renderPass.setVertexBuffer(2, buffers.turret.uv);
                    renderPass.setIndexBuffer(buffers.turret.index, "uint32");

                    // Apply turret position and rotation
                    stack.push(mat4.translate(mat4.clone(MVP), [...turretNode.position]));
                    stack[stack.length - 1] = mat4.rotateY(stack[stack.length - 1], turretNode.rotation.y);
                    MVP = stack[stack.length - 1];

                    worldValue.set(mat4.translate(mat4.clone(MVP), [...buffers.turret.localPosition]));
                    worldViewProjectionValue.set(mat4.multiply(baseMatrix, worldValue));
                    device.queue.writeBuffer(uniformBuffers.turret, 0, uniformValues);
                    renderPass.setBindGroup(0, bindGroups.turret);
                    renderPass.drawIndexed(buffers.turret.count);
            


                    /******** Barrel ********/
                    renderPass.setVertexBuffer(0, buffers.barrel.position);
                    renderPass.setVertexBuffer(1, buffers.barrel.normal);
                    renderPass.setVertexBuffer(2, buffers.barrel.uv);
                    renderPass.setIndexBuffer(buffers.barrel.index, "uint32");

                    // Apply barrel position and rotation
                    stack.push(mat4.translate(mat4.clone(MVP), [...barrelNode.position]));
                    stack[stack.length - 1] = mat4.rotateZ(stack[stack.length - 1], barrelNode.rotation.z);
                    MVP = stack[stack.length - 1];

                    worldValue.set(mat4.translate(mat4.clone(MVP), [...buffers.barrel.localPosition]))
                    worldViewProjectionValue.set(mat4.multiply(baseMatrix, worldValue));
                    device.queue.writeBuffer(uniformBuffers.barrel, 0, uniformValues);
                    renderPass.setBindGroup(0, bindGroups.barrel);
                    renderPass.drawIndexed(buffers.barrel.count);
                    
                    barrelWorldMatrix = MVP;

                    // Shell rendering and update
                    const updatedShells = [];
                    shells.forEach((shell) => {
                        if (!isPaused) {
                            const gravity = vec3.create(0, -0.01, 0);
                    
                            // Adjust gravity
                            shell.direction = vec3.add(shell.direction, gravity);
                            vec3.normalize(shell.direction, shell.direction);
                    
                            // Update shell position
                            shell.position = vec3.add(
                                shell.position,
                                vec3.scale(shell.direction, shell.velocity * 0.1)
                            );
                    
                            // Rotate z axis as falling
                            const zRotationMatrix = mat4.rotateZ(mat4.identity(), -utils.degToRad(0.5));
                            shell.rotationMatrix = mat4.multiply(shell.rotationMatrix, zRotationMatrix);
                        }

                        if (shell.position[1] > 0) {
                            let shellMatrix = mat4.translate(mat4.identity(), shell.position);
                            shellMatrix = mat4.multiply(shellMatrix, shell.rotationMatrix);

                            shell.render(renderPass, mat4.multiply(baseMatrix, shellMatrix), UI);
                    
                            updatedShells.push(shell);
                        }
                    });
                    shells = updatedShells;


                    stack.pop(); // Barrel
                    stack.pop(); // Turret
                }
            
                return { render };
            }

            async function loadShellobj(device, preferredFormat) {

                const loader = new OBJLoader();

                const shell_url = "./shell.obj"
                const root = await new Promise((resolve,reject) => {
                    loader.load(shell_url,
                        (model) => {resolve(model);},
                        null,
                        (error) => {reject(error);});
                });


                const obj = root.children[0];

                const positions = obj.geometry.attributes.position.array;
                const normals = obj.geometry.attributes.normal.array;
                const uvs = obj.geometry.attributes.uv.array;

                const vertexBuffer = {};

                vertexBuffer.position = device.createBuffer({
                    label:"obj mesh positions",
                    size: positions.byteLength,
                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                });

                device.queue.writeBuffer(vertexBuffer.position, 0, positions);

                vertexBuffer.normal = device.createBuffer({
                    label:"obj mesh normals",
                    size: normals.byteLength,
                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                });

                device.queue.writeBuffer(vertexBuffer.normal, 0, normals);

                vertexBuffer.uv = device.createBuffer({
                    label:"obj mesh uvs",
                    size: uvs.byteLength,
                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                });

                device.queue.writeBuffer(vertexBuffer.uv, 0, uvs);

                // Create textures
                const colorTexture = await getTexture(device, "./textures/shell-color.png");
                const etcTexture = await getTexture(device, "./textures/shell-etc.png")
                const normalTexture = await getTexture(device, "./textures/shell-normal.png")

                const sampler = device.createSampler({magFilter:"linear", minFilter:"linear"});

                const bindGroupLayout = createBindGroupLayout(device);
            
                const uniformBufferSize = (16 + 16 + 4 + 4) * 4;
                const uniformBuffer = device.createBuffer({
                        size: uniformBufferSize,
                        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                });
                
                // offsets to the various uniform values in float32 indices
                const uniformValues = new Float32Array(uniformBufferSize / 4);
                const kWorldOffset = 0;
                const kWorldViewProjectionOffset = 16;
                const kLightDirectionOffset = 32;
                const kViewWorldPositionOffset = 36;

                
                const worldValue = uniformValues.subarray(kWorldOffset, kWorldOffset + 16);
                const worldViewProjectionValue = uniformValues.subarray(
                    kWorldViewProjectionOffset, kWorldViewProjectionOffset + 16);
                const lightDirectionValue =
                    uniformValues.subarray(kLightDirectionOffset, kLightDirectionOffset + 3);
                const viewWorldPositionValue = uniformValues.subarray(
                    kViewWorldPositionOffset, kViewWorldPositionOffset + 3);
            
                const src_shaders = `
                    struct VertexOut {
                        @builtin(position) position: vec4f,
                        @location(${loc_inter_stage_normal}) normal: vec3f,
                        @location(${loc_inter_stage_uv}) uv: vec2f,
                        @location(${loc_inter_stage_position}) pos: vec3f,
                        @location(${loc_inter_stage_surfaceToView}) surfaceToView: vec3f
                    };

                    struct Uniforms {
                        world: mat4x4f,
                        worldViewProjection: mat4x4f,
                        lightDirection: vec3f,
                        viewWorldPosition: vec3f,
                    };
            
                    @group(0) @binding(${binding_uniforms}) var<uniform> uni: Uniforms;
                    @group(0) @binding(${binding_sampler}) var my_sampler: sampler;
                    @group(0) @binding(${binding_color_texture}) var colorTexture: texture_2d<f32>;
                    @group(0) @binding(${binding_etc_texture}) var etcTexture: texture_2d<f32>;
                    @group(0) @binding(${binding_normal_texture}) var normalTexture: texture_2d<f32>;
            
                    @vertex
                    fn main_vert(
                        @location(${loc_position}) position: vec3f, 
                        @location(${loc_normal}) normal: vec3f,
                        @location(${loc_uv}) uv: vec2f
                    ) -> VertexOut {
                        var output: VertexOut;
                        output.position = uni.worldViewProjection * vec4f(position, 1.0);
                        output.normal = normalize((uni.world * vec4f(normal, 0)).xyz);
                        output.uv = uv;
                        output.pos = position;
                        let surfaceWorldPosition = (uni.world * vec4f(position, 1.0)).xyz;
                        output.surfaceToView = -uni.viewWorldPosition - surfaceWorldPosition;

                        return output;
                    }
            
                    @fragment
                    fn main_frag(
                        @location(${loc_inter_stage_normal}) normal: vec3f,
                        @location(${loc_inter_stage_uv}) uv: vec2f,
                        @location(${loc_inter_stage_position}) pos: vec3f,
                        @location(${loc_inter_stage_surfaceToView}) surfaceToView: vec3f
                    ) -> @location(0) vec4f {
                        // Calcualte perturbed normal
                        let norm = 2*(textureSample(normalTexture, my_sampler, uv).xyz - vec3f(.5));
                        let TBN = cotangent_frame(normal, -pos.xyz, uv);
                        let n = normalize(vec4(TBN*norm.xyz, 0)).xyz;
                        
                        // Calculate light
                        let texColor = textureSample(colorTexture, my_sampler, uv);
                        let etcColor = textureSample(etcTexture, my_sampler, uv);
                        let ao = etcColor.r;
                        let shininess = etcColor.g;
                        let metalness = etcColor.b;

                        let surfaceToLightDirection = normalize(-uni.lightDirection);
                        let surfaceToViewDirection = normalize(surfaceToView);
                        let halfVector = normalize(
                        surfaceToLightDirection + surfaceToViewDirection);

                        let light = dot(n, surfaceToLightDirection);
                        var specular = dot(n, halfVector);
                        specular = select(
                            0.0,                           // value if condition is false
                            pow(specular, shininess),  // value if condition is true
                            specular > 0.0);               // condition

                        // Ambient reflection
                        let ambientIntensity = 0.2; // Ambient light intensity (adjust as needed)
                        let ambientColor = vec3f(0.2, 0.2, 0.2); // Environment color (dark gray)
                        let ambient = ambientColor * ambientIntensity;

                        // Final color calculation
                        let diffuse = (texColor.rgb * light) * ao;
                        let finalColor = diffuse + specular * metalness + ambient;

                        return vec4f(finalColor, texColor.a);
                    }

                    fn cotangent_frame(N: vec3f, p: vec3f, uv: vec2f) -> mat3x3f {
                        let dp1 = dpdx(p);
                        let dp2 = dpdy(p);
                        let duv1 = dpdx(uv);
                        let duv2 = dpdy(uv);

                        let dp2perp = cross(dp2, N);
                        let dp1perp = cross(N, dp1);
                        let T = dp2perp * duv1.x + dp1perp * duv2.x;
                        let B = dp2perp * duv1.y + dp1perp * duv2.y;

                        let invmax = inverseSqrt(max(dot(T,T), dot(B,B)));
                        return mat3x3f(T*invmax, B*invmax, N);
                    }

                `;
            
                const shaderModule = device.createShaderModule({
                    code: src_shaders,
                });
            
                const bindGroup = createBindGroup(device, bindGroupLayout, uniformBuffer, 
                    sampler, colorTexture, etcTexture, normalTexture);

                const pipeline = device.createRenderPipeline({
                    layout: device.createPipelineLayout({ bindGroupLayouts: [bindGroupLayout] }),
                    vertex: {
                        module: shaderModule,
                        entryPoint: "main_vert",
                        buffers: [
                            {
                                arrayStride: 4 * 3,
                                attributes: [{ format: "float32x3", offset: 0, shaderLocation: loc_position }],
                            },
                            {
                                arrayStride: 4 * 3,
                                attributes: [{ format: "float32x3", offset: 0, shaderLocation: loc_normal }],
                            },
                            {
                                arrayStride: 4 * 2,
                                attributes: [{ format: "float32x2", offset: 0, shaderLocation: loc_uv }],
                            },
                        ],
                    },
                    fragment: {
                        module: shaderModule,
                        entryPoint: "main_frag",
                        targets: [{ format: preferredFormat }],
                    },
                    primitive: { topology: "triangle-list" },
                    depthStencil: {
                        depthWriteEnabled: true,
                        depthCompare: "less",
                        format: format_depth_texture,
                    },
                });
            
                function render(renderPass, baseMatrix, UI) {
                    lightDirectionValue.set(vec3.normalize(light_direction));
                    viewWorldPositionValue.set(UI.camera.position);
                    let MVP = mat4.identity();

                    renderPass.setPipeline(pipeline);
                    renderPass.setVertexBuffer(0, vertexBuffer.position);
                    renderPass.setVertexBuffer(1, vertexBuffer.normal);
                    renderPass.setVertexBuffer(2, vertexBuffer.uv);

                    worldValue.set(MVP);
                    worldViewProjectionValue.set(mat4.multiply(baseMatrix, MVP));
                    device.queue.writeBuffer(uniformBuffer, 0, uniformValues);
                    renderPass.setBindGroup(0, bindGroup);
                    renderPass.draw(obj.geometry.attributes.position.count);
                }
            
                return { render };
            }

            function createGridAndAxes(device, preferredFormat) {
                const gridSize = 10;
                const gridDivision = 10;
                const gridLines = [];
                const gridColor = [0.5, 0.5, 0.5]; // gray
                const axisColors = {
                    x: [1, 0, 0], // red
                    y: [0, 1, 0], // green
                    z: [0, 0, 1], // blue
                    xNegative: [0.3, 0, 0], // dark red
                    yNegative: [0, 0.3, 0], // dark green
                    zNegative: [0, 0, 0.3], // dark blue
                };
            
                // Create grid data
                for (let i = -gridSize; i <= gridSize; i++) {
                    const pos = (i / gridDivision) * gridSize;
                    
                    // exclude axis grid
                    if (i === 0) continue;

                    gridLines.push(-gridSize, 0, pos, ...gridColor);
                    gridLines.push(gridSize, 0, pos, ...gridColor);
                    gridLines.push(pos, 0, -gridSize, ...gridColor);
                    gridLines.push(pos, 0, gridSize, ...gridColor);
                }
            
                // Create axis data (X, Y, Z axis bi-direction)
                const axisLines = [
                    // X axis
                    0, 0, 0, ...axisColors.x, 10, 0, 0, ...axisColors.x,
                    0, 0, 0, ...axisColors.xNegative, -10, 0, 0, ...axisColors.xNegative,
            
                    // Y axis
                    0, 0, 0, ...axisColors.y, 0, 10, 0, ...axisColors.y,
                    0, 0, 0, ...axisColors.yNegative, 0, -10, 0, ...axisColors.yNegative,
            
                    // Z axis
                    0, 0, 0, ...axisColors.z, 0, 0, 10, ...axisColors.z,
                    0, 0, 0, ...axisColors.zNegative, 0, 0, -10, ...axisColors.zNegative,
                ];
            
                const lineData = new Float32Array([...gridLines, ...axisLines]);
            
                const lineBuffer = device.createBuffer({
                    size: lineData.byteLength,
                    usage: GPUBufferUsage.VERTEX,
                    mappedAtCreation: true,
                });
                new Float32Array(lineBuffer.getMappedRange()).set(lineData);
                lineBuffer.unmap();
            
                const lineVertexCount = lineData.length / 6;
            
                const uniformBuffer = device.createBuffer({
                    size: 64,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                });
            
                const lineShader = device.createShaderModule({
                    label: "solid line shader",
                    code: `
                    struct Uniforms {
                        MVP: mat4x4<f32>,
                    };
            
                    @group(0) @binding(0) var<uniform> uniforms: Uniforms;
            
                    struct VertexOutput {
                        @builtin(position) position: vec4<f32>,
                        @location(0) color: vec3<f32>,
                    };
            
                    @vertex
                    fn main_vertex(
                        @location(0) position: vec3<f32>,
                        @location(1) color: vec3<f32>
                    ) -> VertexOutput {
                        var output: VertexOutput;
                        output.position = uniforms.MVP * vec4<f32>(position, 1.0);
                        output.color = color;
                        return output;
                    }
            
                    @fragment
                    fn main_fragment(
                        @location(0) color: vec3<f32>
                    ) -> @location(0) vec4<f32> {
                        return vec4<f32>(color, 1.0);
                    }
                    `,
                });
            
                const pipeline = device.createRenderPipeline({
                    label: "solid line pipeline",
                    layout: "auto",
                    vertex: {
                        module: lineShader,
                        entryPoint: "main_vertex",
                        buffers: [
                            {
                                arrayStride: 4 * 6, // position (vec3) + color (vec3)
                                attributes: [
                                    { shaderLocation: 0, format: "float32x3", offset: 0 },
                                    { shaderLocation: 1, format: "float32x3", offset: 4 * 3 },
                                ],
                            },
                        ],
                    },
                    fragment: {
                        module: lineShader,
                        entryPoint: "main_fragment",
                        targets: [{ format: preferredFormat }],
                    },
                    primitive: {
                        topology: "line-list",
                    },
                    depthStencil: {
                        depthWriteEnabled: true,
                        depthCompare: "less",
                        format: format_depth_texture,
                    },
                });
            
                const bindGroup = device.createBindGroup({
                    layout: pipeline.getBindGroupLayout(0),
                    entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],
                });
            
                return {
                    render(renderPass, MVP) {
                        renderPass.setPipeline(pipeline);
                        renderPass.setBindGroup(0, bindGroup);
                        device.queue.writeBuffer(uniformBuffer, 0, MVP);
                        renderPass.setVertexBuffer(0, lineBuffer);
                        renderPass.draw(lineVertexCount);
                    },
                };
            }

            function createAxes(device, preferredFormat) {
                const axisColors = {
                    x: [1, 0, 0], // red
                    y: [0, 1, 0], // green
                    z: [0, 0, 1], // blue
                    xNegative: [0.3, 0, 0], // dark red
                    yNegative: [0, 0.3, 0], // dark green
                    zNegative: [0, 0, 0.3], // dark blue
                };
            
                // Create axis data (X, Y, Z axis bi-direction)
                const axisLines = [
                    // X axis
                    0, 0.01, 0, ...axisColors.x, 2, 0.01, 0, ...axisColors.x,
                    0, 0.01, 0, ...axisColors.xNegative, -2, 0.01, 0, ...axisColors.xNegative,
            
                    // Y axis
                    0, 0, 0, ...axisColors.y, 0, 2, 0, ...axisColors.y,
                    0, 0, 0, ...axisColors.yNegative, 0, -2, 0, ...axisColors.yNegative,
            
                    // Z axis
                    0, 0.01, 0, ...axisColors.z, 0, 0.01, 2, ...axisColors.z,
                    0, 0.01, 0, ...axisColors.zNegative, 0, 0.01, -2, ...axisColors.zNegative,
                ];
            
                const lineData = new Float32Array([...axisLines]);
            
                const lineBuffer = device.createBuffer({
                    size: lineData.byteLength,
                    usage: GPUBufferUsage.VERTEX,
                    mappedAtCreation: true,
                });
                new Float32Array(lineBuffer.getMappedRange()).set(lineData);
                lineBuffer.unmap();
            
                const lineVertexCount = lineData.length / 6;
            
                const uniformBuffer = device.createBuffer({
                    size: 64,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
                });
            
                const lineShader = device.createShaderModule({
                    label: "solid line shader",
                    code: `
                    struct Uniforms {
                        MVP: mat4x4<f32>,
                    };
            
                    @group(0) @binding(0) var<uniform> uniforms: Uniforms;
            
                    struct VertexOutput {
                        @builtin(position) position: vec4<f32>,
                        @location(0) color: vec3<f32>,
                    };
            
                    @vertex
                    fn main_vertex(
                        @location(0) position: vec3<f32>,
                        @location(1) color: vec3<f32>
                    ) -> VertexOutput {
                        var output: VertexOutput;
                        output.position = uniforms.MVP * vec4<f32>(position, 1.0);
                        output.color = color;
                        return output;
                    }
            
                    @fragment
                    fn main_fragment(
                        @location(0) color: vec3<f32>
                    ) -> @location(0) vec4<f32> {
                        return vec4<f32>(color, 1.0);
                    }
                    `,
                });
            
                const pipeline = device.createRenderPipeline({
                    label: "solid line pipeline",
                    layout: "auto",
                    vertex: {
                        module: lineShader,
                        entryPoint: "main_vertex",
                        buffers: [
                            {
                                arrayStride: 4 * 6, // position (vec3) + color (vec3)
                                attributes: [
                                    { shaderLocation: 0, format: "float32x3", offset: 0 },
                                    { shaderLocation: 1, format: "float32x3", offset: 4 * 3 },
                                ],
                            },
                        ],
                    },
                    fragment: {
                        module: lineShader,
                        entryPoint: "main_fragment",
                        targets: [{ format: preferredFormat }],
                    },
                    primitive: {
                        topology: "line-list",
                    },
                    depthStencil: {
                        depthWriteEnabled: true,
                        depthCompare: "less",
                        format: format_depth_texture,
                    },
                });
            
                const bindGroup = device.createBindGroup({
                    layout: pipeline.getBindGroupLayout(0),
                    entries: [{ binding: 0, resource: { buffer: uniformBuffer } }],
                });
            
                return {
                    render(renderPass, MVP) {
                        renderPass.setPipeline(pipeline);
                        renderPass.setBindGroup(0, bindGroup);
                        device.queue.writeBuffer(uniformBuffer, 0, MVP);
                        renderPass.setVertexBuffer(0, lineBuffer);
                        renderPass.draw(lineVertexCount);
                    },
                };
            }

            async function getTexture(device, texture_url) {
                const response = await fetch(texture_url);
                const blob = await response.blob();
                const bitmap = await createImageBitmap(blob, { colorSpaceConversion: "none" });
                const texture = device.createTexture({
                    label: texture_url,
                    format: "rgba8unorm",
                    size: [bitmap.width, bitmap.height],
                    usage:  GPUTextureUsage.TEXTURE_BINDING |
                            GPUTextureUsage.COPY_DST |
                            GPUTextureUsage.RENDER_ATTACHMENT,
                });
                device.queue.copyExternalImageToTexture(
                    { source: bitmap, flipY: false },
                    { texture: texture },
                    { width: bitmap.width, height: bitmap.height },
                );
                return texture;
            }

            function createBindGroup(device, layout, uniformBuffer, sampler, colorTexture, etcTexture, normalTexture) {
                return device.createBindGroup({
                    layout,
                    entries: [
                        { binding: binding_uniforms, resource: { buffer: uniformBuffer } },
                        { binding: binding_sampler, resource: sampler },               
                        { binding: binding_color_texture, resource: colorTexture.createView() },
                        { binding: binding_etc_texture, resource: etcTexture.createView() },
                        { binding: binding_normal_texture, resource: normalTexture.createView() } 
                    ],
                });
            }

            function createBindGroupLayout(device) {
                return device.createBindGroupLayout({
                    entries: [
                        { binding: binding_uniforms, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: {} },
                        { binding: binding_sampler, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
                        { binding: binding_color_texture, visibility: GPUShaderStage.FRAGMENT, texture: {} },
                        { binding: binding_etc_texture, visibility: GPUShaderStage.FRAGMENT, texture: {} },
                        { binding: binding_normal_texture, visibility: GPUShaderStage.FRAGMENT, texture: {} },
                    ],
                });
            }

            // https://github.com/g-truc/glm/blob/master/glm/ext/matrix_projection.inl
            function project(p_obj, MVP, viewport)
            {
                let tmp = vec4.transformMat4(p_obj, MVP);
                tmp = tmp.map((x) => x/tmp[3]); // tmp /= tmp[3]
                for(let i=0 ; i<2 ; i++) {
                    tmp[i] = (0.5*tmp[i] + 0.5) * viewport[i+2] + viewport[i];
                }
                return tmp;
            }
            
            // https://github.com/g-truc/glm/blob/master/glm/ext/matrix_projection.inl
            function unproject(p_win, MVP, viewport) {
                let MVP_inv = mat4.invert(MVP);
                let tmp = mat4.clone(p_win);
            
                for (let i = 0; i < 2; i++)
                    tmp[i] = 2.0 * (tmp[i] - viewport[i]) / viewport[i+2] - 1.0;
            
                let p_obj = vec4.transformMat4(tmp, MVP_inv);
            
                p_obj = p_obj.map((x) => x/p_obj[3]);
            
                return p_obj;
            }

            function unproject_vector(vec_win, MVP, viewport)
            {
                let org_win = project([0,0,0,1], MVP, viewport);
                let vec = unproject([org_win[0]+vec_win[0], org_win[1]+vec_win[1], org_win[2]+vec_win[2], 1],
                                    MVP, viewport);
                return vec;
            }




            main();
        </script>

        <table align="center">
            <tbody><tr><td>
                <div align="center">
                    <canvas id="webgpu" width="720," height="580">
                    </canvas>
                </div>
            </td></tr>
            <tr><td>
                <div align="center" id="key-info">
                    The key "<span id="current-key">None</span>" is down.
                </div>
            </td></tr>
        </tbody></table>

    

</body></html>